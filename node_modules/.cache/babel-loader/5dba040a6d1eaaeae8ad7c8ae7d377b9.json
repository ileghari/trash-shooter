{"ast":null,"code":"// to avoid repeating similar template literals to create curves\nexport const pathFromBezierCurve = cubicBezierCurve => {\n  const {\n    initialAxis,\n    initialControlPoint,\n    endingControlPoint,\n    endingAxis\n  } = cubicBezierCurve;\n  return `\n    M${initialAxis.x} ${initialAxis.y}\n    c ${initialControlPoint.x} ${initialControlPoint.y}\n    ${endingControlPoint.x} ${endingControlPoint.y}\n    ${endingAxis.x} ${endingAxis.y}\n    `;\n}; // formula for caluclating angle between two coordinates\n\nexport const radiansToDegrees = radians => radians * 180 / Math.PI;\nexport const calculateAngle = (x1, y1, x2, y2) => {\n  if (x2 >= 0 && y2 >= 0) {\n    return 90;\n  } else if (x2 < 0 && y2 >= 0) {\n    return -90;\n  }\n\n  const dividend = x2 - x1;\n  const divisor = y2 - y1;\n  const quotient = dividend / divider;\n  return radiansToDegrees(Math.atan(quotient)) * -1;\n};\nexport const getCanvasPosition = event => {\n  // Find your root SVG element\n  const svg = document.getElementById('trash-shooter-canvas'); // Create an SVGPoint for future math\n\n  const point = svg.createSVPoint(); // Get point in global SVG space\n\n  point.x = event.clientX;\n  point.y = event.clientY;\n  const {\n    x,\n    y\n  } = point.matrixTransform(svg.getScreenCTM().inverse());\n  return {\n    x,\n    y\n  };\n};","map":{"version":3,"sources":["/Users/ileghari/Documents/Projects/trash-shooter/src/utils/formulas.js"],"names":["pathFromBezierCurve","cubicBezierCurve","initialAxis","initialControlPoint","endingControlPoint","endingAxis","x","y","radiansToDegrees","radians","Math","PI","calculateAngle","x1","y1","x2","y2","dividend","divisor","quotient","divider","atan","getCanvasPosition","event","svg","document","getElementById","point","createSVPoint","clientX","clientY","matrixTransform","getScreenCTM","inverse"],"mappings":"AAAA;AAEA,OAAO,MAAMA,mBAAmB,GAAIC,gBAAD,IAAsB;AACvD,QAAM;AACJC,IAAAA,WADI;AAEJC,IAAAA,mBAFI;AAGJC,IAAAA,kBAHI;AAIJC,IAAAA;AAJI,MAKFJ,gBALJ;AAOA,SAAQ;AACV,OAAOC,WAAW,CAACI,CAAE,IAAGJ,WAAW,CAACK,CAAE;AACtC,QAAQJ,mBAAmB,CAACG,CAAE,IAAGH,mBAAmB,CAACI,CAAE;AACvD,MAAMH,kBAAkB,CAACE,CAAE,IAAGF,kBAAkB,CAACG,CAAE;AACnD,MAAMF,UAAU,CAACC,CAAE,IAAGD,UAAU,CAACE,CAAE;AACnC,KALE;AAMD,CAdM,C,CAgBP;;AAEA,OAAO,MAAMC,gBAAgB,GAAIC,OAAD,IAAcA,OAAO,GAAG,GAAX,GAAkBC,IAAI,CAACC,EAA7D;AAEP,OAAO,MAAMC,cAAc,GAAG,CAACC,EAAD,EAAKC,EAAL,EAASC,EAAT,EAAaC,EAAb,KAAoB;AAChD,MAAID,EAAE,IAAI,CAAN,IAAWC,EAAE,IAAI,CAArB,EAAwB;AACtB,WAAO,EAAP;AACD,GAFD,MAEO,IAAID,EAAE,GAAG,CAAL,IAAUC,EAAE,IAAI,CAApB,EAAuB;AAC5B,WAAO,CAAC,EAAR;AACD;;AAED,QAAMC,QAAQ,GAAGF,EAAE,GAAGF,EAAtB;AACA,QAAMK,OAAO,GAAGF,EAAE,GAAGF,EAArB;AACA,QAAMK,QAAQ,GAAGF,QAAQ,GAAGG,OAA5B;AACA,SAAOZ,gBAAgB,CAACE,IAAI,CAACW,IAAL,CAAUF,QAAV,CAAD,CAAhB,GAAwC,CAAC,CAAhD;AACD,CAXM;AAaP,OAAO,MAAMG,iBAAiB,GAAIC,KAAD,IAAW;AAC1C;AACA,QAAMC,GAAG,GAAGC,QAAQ,CAACC,cAAT,CAAwB,sBAAxB,CAAZ,CAF0C,CAI1C;;AACA,QAAMC,KAAK,GAAGH,GAAG,CAACI,aAAJ,EAAd,CAL0C,CAO1C;;AACAD,EAAAA,KAAK,CAACrB,CAAN,GAAUiB,KAAK,CAACM,OAAhB;AACAF,EAAAA,KAAK,CAACpB,CAAN,GAAUgB,KAAK,CAACO,OAAhB;AAEA,QAAM;AAAExB,IAAAA,CAAF;AAAKC,IAAAA;AAAL,MAAWoB,KAAK,CAACI,eAAN,CAAsBP,GAAG,CAACQ,YAAJ,GAAmBC,OAAnB,EAAtB,CAAjB;AACA,SAAO;AAAE3B,IAAAA,CAAF;AAAKC,IAAAA;AAAL,GAAP;AACD,CAbM","sourcesContent":["// to avoid repeating similar template literals to create curves\n\nexport const pathFromBezierCurve = (cubicBezierCurve) => {\n  const {\n    initialAxis,\n    initialControlPoint,\n    endingControlPoint,\n    endingAxis,\n  } = cubicBezierCurve;\n\n  return `\n    M${initialAxis.x} ${initialAxis.y}\n    c ${initialControlPoint.x} ${initialControlPoint.y}\n    ${endingControlPoint.x} ${endingControlPoint.y}\n    ${endingAxis.x} ${endingAxis.y}\n    `;\n};\n\n// formula for caluclating angle between two coordinates\n\nexport const radiansToDegrees = (radians) => (radians * 180) / Math.PI;\n\nexport const calculateAngle = (x1, y1, x2, y2) => {\n  if (x2 >= 0 && y2 >= 0) {\n    return 90;\n  } else if (x2 < 0 && y2 >= 0) {\n    return -90;\n  }\n\n  const dividend = x2 - x1;\n  const divisor = y2 - y1;\n  const quotient = dividend / divider;\n  return radiansToDegrees(Math.atan(quotient)) * -1;\n};\n\nexport const getCanvasPosition = (event) => {\n  // Find your root SVG element\n  const svg = document.getElementById('trash-shooter-canvas');\n\n  // Create an SVGPoint for future math\n  const point = svg.createSVPoint();\n\n  // Get point in global SVG space\n  point.x = event.clientX;\n  point.y = event.clientY;\n\n  const { x, y } = point.matrixTransform(svg.getScreenCTM().inverse());\n  return { x, y };\n};\n"]},"metadata":{},"sourceType":"module"}